[
  {
    "title": "adaptive blur",
    "command": "-adaptive-blur geometry",
    "description": "Applies an adaptive blur to the image, reducing the effect near edges to preserve contours.",
    "example": "convert input -adaptive-blur 0x8 output",
    "intent": "I want to blur the image adaptively while preserving edges (less blur near boundaries).",
    "input_type": {}
  },
  {
    "title": "adaptive resize",
    "command": "-adaptive-resize geometry",
    "description": "Resizes the image adaptively using data-dependent triangulation to better preserve detail.",
    "example": "convert input -adaptive-resize 800x600 output",
    "intent": "I want to resize my image while preserving as much detail as possible / use adaptive resizing.",
    "input_type": {}
  },
  {
    "title": "adaptive sharpen",
    "command": "-adaptive-sharpen geometry",
    "description": "Sharpen the image adaptively, emphasizing edges more than uniform areas.",
    "example": "convert input -adaptive-sharpen 0x2 output",
    "intent": "I want to make the image sharper by emphasizing edges without boosting smooth regions.",
    "input_type": {}
  },
  {
    "title": "image merging",
    "command": "-adjoin",
    "description": "Combines multiple images into a single multi-image file (e.g., a GIF or multi-page TIFF).",
    "example": "convert input1.png input2.png -adjoin output.tiff",
    "intent": "I want to merge multiple images into a single multi-image file (e.g., GIF or multi-page TIFF).",
    "input_type": {}
  },
  {
    "title": "affine transformation",
    "command": "-affine matrix",
    "description": "Applies an affine transformation defined by a matrix (rotation, translation, shear, etc.).",
    "example": "convert input -affine 1,0.2,0,1,0,0 -transform output",
    "intent": "I want to apply a geometric transform to the image (rotation, translation, shear) to change its shape or position.",
    "input_type": {}
  },
  {
    "title": "alpha channel control",
    "command": "-alpha option",
    "description": "Controls the alpha channel: enable, disable, copy, make opaque, make transparent, extract, etc.",
    "example": "convert input -alpha set -channel A -evaluate set 0 output",
    "intent": "I want to control the image's alpha channel (enable/disable, make transparent/opaque, extract or copy transparency).",
    "input_type": {}
  },
  {
    "title": "text annotation",
    "command": "-annotate geometry text",
    "description": "Adds text to the image at a specified position. The -geometry option controls placement and size.",
    "example": "convert input -annotate +30+50 'Hello World' output",
    "intent": "I want to add text to the image at a specified location (write text at an exact position).",
    "input_type": {}
  },
  {
    "title": "antialiasing",
    "command": "-antialias",
    "description": "Removes or reduces pixel aliasing, useful for improving the edges of text or shapes.",
    "example": "convert input -antialias output",
    "intent": "I want to smooth edges to reduce stair-stepping (aliasing) and improve rendering of text or shapes.",
    "input_type": {}
  },
  {
    "title": "image concatenation",
    "command": "-append",
    "description": "Concatenates multiple images into one, vertically by default (or horizontally with +append).",
    "example": "convert image1.png image2.png -append output.png",
    "intent": "I want to assemble multiple images into a single continuous image, vertically (or horizontally if desired).",
    "input_type": {}
  },
  {
    "title": "image decryption",
    "command": "-authenticate value",
    "description": "Decrypts a password-protected image using the provided key.",
    "example": "convert encrypted.miff -authenticate 'password123' output.png",
    "intent": "I want to decrypt/unlock a protected image by providing the password or key so I can open/save it.",
    "input_type": {}
  },
  {
    "title": "automatic gamma adjustment",
    "command": "-auto-gamma",
    "description": "Automatically adjusts the image gamma to balance highlights and shadows.",
    "example": "convert input -auto-gamma output",
    "intent": "I want to automatically adjust the image gamma to balance highlights and shadows.",
    "input_type": {}
  },
  {
    "title": "automatic levels adjustment",
    "command": "-auto-level",
    "description": "Automatically balances color levels to maximize dynamic range.",
    "example": "convert input -auto-level output",
    "intent": "I want to automatically balance color levels to maximize dynamic range or improve contrast.",
    "input_type": {}
  },
  {
    "title": "automatic orientation",
    "command": "-auto-orient",
    "description": "Automatically orients the image based on EXIF metadata (useful for smartphone photos).",
    "example": "convert input -auto-orient output",
    "intent": "I want to automatically orient the image using its EXIF metadata to correct rotation (useful for smartphone photos).",
    "input_type": {}
  },
  {
    "title": "background color",
    "command": "-background color",
    "description": "Sets the background color used for compositing or text operations.",
    "example": "convert input -background white -flatten output",
    "intent": "I want to set the background color used for compositing or text.",
    "input_type": {}
  },
  {
    "title": "performance benchmark",
    "command": "-bench iterations",
    "description": "Measures performance by running the same command multiple times to time execution speed.",
    "example": "convert input -bench 10 -resize 50% output",
    "intent": "I want to measure processing performance by running the same operation multiple times to time its speed.",
    "input_type": {}
  },
  {
    "title": "convolution bias",
    "command": "-bias value",
    "description": "Adds a bias during image convolution, affecting the contrast or brightness of the result.",
    "example": "convert input -bias 10% -convolve '0,1,0,1,4,1,0,1,0' output",
    "intent": "I want to add a bias during convolution to influence the contrast/brightness of the output.",
    "input_type": {}
  },
  {
    "title": "bilateral blur",
    "command": "-bilateral-blur geometry",
    "description": "Applies a bilateral blur: smooths uniform areas while preserving sharp edges.",
    "example": "convert input -bilateral-blur 0x5 output",
    "intent": "I want to apply a bilateral blur to smooth uniform areas while preserving edges.",
    "input_type": {}
  },
  {
    "title": "black threshold",
    "command": "-black-threshold value",
    "description": "Forces all pixels below the given threshold to become black, useful for creating masks.",
    "example": "convert input -black-threshold 20% output",
    "intent": "I want to turn all pixels below a threshold to black to create a mask.",
    "input_type": {}
  },
  {
    "title": "blue primary point",
    "command": "-blue-primary point",
    "description": "Sets the chromaticity coordinates of the blue primary in the color space.",
    "example": "convert input -blue-primary 0.15,0.06 output",
    "intent": "I want to set the blue chromaticity point to adjust the blue reference in the color space.",
    "input_type": {}
  },
  {
    "title": "blue shift",
    "command": "-blue-shift factor",
    "description": "Simulates a moonlit scene by applying a blue shift effect.",
    "example": "convert input -blue-shift 1.5 output",
    "intent": "I want to apply a blue shift to give a cooler appearance or simulate moonlight.",
    "input_type": {}
  },
  {
    "title": "Gaussian blur",
    "command": "-blur geometry",
    "description": "Applies a Gaussian blur to reduce noise and soften image details.",
    "example": "convert input -blur 0x8 output",
    "intent": "I want to soften/smooth the image and reduce noise by applying a Gaussian blur.",
    "input_type": {}
  },
  {
    "title": "Add a border",
    "command": "-border geometry",
    "description": "Adds a border around the image using the color specified by -bordercolor.",
    "example": "convert input -border 10x10 -bordercolor black output",
    "intent": "I want to add a border/frame around the image using a chosen color.",
    "input_type": {}
  },
  {
    "title": "Border color",
    "command": "-bordercolor color",
    "description": "Sets the color used for borders added by -border.",
    "example": "convert input -bordercolor red -border 5x5 output",
    "intent": "I want to set the color of the border/frame that will be added around the image.",
    "input_type": {}
  },
  {
    "title": "Brightness and contrast",
    "command": "-brightness-contrast geometry",
    "description": "Adjusts the image's brightness and contrast by modifying dark and light tones.",
    "example": "convert input -brightness-contrast 10x15 output",
    "intent": "I want to adjust brightness (lighten/darken) and contrast to make light and dark areas more or less prominent.",
    "input_type": {}
  },
  {
    "title": "Edge detection (Canny)",
    "command": "-canny geometry",
    "description": "Detects image edges using the multi-stage Canny algorithm.",
    "example": "convert input -canny 0x1+10%+30% output",
    "intent": "I want to detect/highlight contours and edges in the image using the Canny algorithm.",
    "input_type": {}
  },
  {
    "title": "Add caption",
    "command": "-caption string",
    "description": "Assigns a caption to the image (displayed depending on context).",
    "example": "convert input -caption 'Vue du Mont Fuji' output",
    "intent": "I want to add a caption/description text to the image that will be shown with it.",
    "input_type": {}
  },
  {
    "title": "CDL color correction",
    "command": "-cdl filename",
    "description": "Applies color correction using a Color Decision List (CDL).",
    "example": "convert input -cdl correction.cdl output",
    "intent": "I want to apply a predefined color correction using a CDL file to adjust the image colors.",
    "input_type": {}
  },
  {
    "title": "Channel selection",
    "command": "-channel type",
    "description": "Selects image channels (R, G, B, A, etc.) to which the following operation will apply.",
    "example": "convert input -channel R -equalize output",
    "intent": "I want to select one or more channels (R, G, B, A) so the next operation only affects those channels.",
    "input_type": {}
  },
  {
    "title": "Charcoal drawing effect",
    "command": "-charcoal radius",
    "description": "Simulates a charcoal drawing from the original image.",
    "example": "convert input -charcoal 2 output",
    "intent": "I want to transform the image to give it a charcoal/drawing-like appearance.",
    "input_type": {}
  },
  {
    "title": "Internal chop",
    "command": "-chop geometry",
    "description": "Removes a strip of pixels from the inside of the image according to the specified geometry.",
    "example": "convert input -chop 50x10+0+0 output",
    "intent": "I want to remove/cut out an internal strip from the image at specific dimensions and position.",
    "input_type": {}
  },
  {
    "title": "Adaptive Contrast Equalization (CLAHE)",
    "command": "-clahe geometry",
    "input_type": {},
    "description": "Enhances local contrast by applying Contrast Limited Adaptive Histogram Equalization (CLAHE).",
    "example": "convert input -clahe 10x10+128+3 output",
    "intent": "I want to improve/localize the contrast of my image by applying Contrast Limited Adaptive Histogram Equalization (CLAHE) to reveal more detail."
  },
  {
    "title": "Value Clamping (clamp)",
    "command": "-clamp",
    "input_type": {},
    "description": "Forces pixels outside the valid range (below 0 or above the quantum range) back within bounds.",
    "example": "convert input -clamp output",
    "intent": "I want to bring out-of-range pixel values (too low or too high) back into the valid range to avoid incorrect colors or values."
  },
  {
    "title": "Clipping by 8BIM Path",
    "command": "-clip",
    "input_type": {},
    "description": "Clips the image according to the first path stored in the 8BIM (Photoshop) profile.",
    "example": "convert input -clip output",
    "intent": "I want to clip/mask my image using the first path stored in the 8BIM metadata (like a Photoshop path)."
  },
  {
    "title": "Clip Mask",
    "command": "-clip-mask filename",
    "input_type": {},
    "description": "Associates an external clip mask with the image for clipping/cutouts.",
    "example": "convert input -clip-mask mask.png output",
    "intent": "I want to use an external mask image to clip/cut out my image so only the desired area remains."
  },
  {
    "title": "Clip by Named Path",
    "command": "-clip-path id",
    "input_type": {},
    "description": "Clips the image using a named path stored in the 8BIM profile.",
    "example": "convert input -clip-path 'path1' output",
    "intent": "I want to clip/mask the image using a named path (identified by id) present in the 8BIM data."
  },
  {
    "title": "Clone Image",
    "command": "-clone index",
    "input_type": {},
    "description": "Clones a specific image from a sequence of images (index is zero-based).",
    "example": "convert input.png ( +clone -rotate 90 ) -append output.png",
    "intent": "I want to clone/duplicate a specific image from a sequence (indexed from 0) to reuse or transform it separately."
  },
  {
    "title": "Color Look-Up Table (CLUT)",
    "command": "-clut",
    "input_type": {},
    "description": "Applies a Color Look-Up Table (CLUT) to the image.",
    "example": "convert input lut.png -clut output",
    "intent": "I want to modify or remap the image colors by applying a Color Look-Up Table (CLUT)."
  },
  {
    "title": "Connected Components",
    "command": "-connected-components connectivity",
    "input_type": {},
    "description": "Assigns a unique label to each connected component based on 4- or 8-connectivity.",
    "example": "convert input -connected-components 8 output",
    "intent": "I want to detect and label each connected component in the image (4- or 8-connectivity) to isolate or count objects."
  },
  {
    "title": "Contrast Stretch",
    "command": "-contrast-stretch geometry",
    "input_type": {},
    "description": "Enhances overall contrast by stretching the range of intensity values.",
    "example": "convert input -contrast-stretch 5%x5% output",
    "intent": "I want to increase the image's overall contrast by stretching the intensity range so highlights and shadows are more distinct."
  },
  {
    "title": "Coalesce",
    "command": "-coalesce",
    "input_type": {},
    "description": "Coalesces an image sequence (e.g., an animated GIF) into a continuous set of full frames.",
    "example": "convert animation.gif -coalesce frames_%03d.png",
    "intent": "I want to convert an animation (for example a GIF) into a sequence of complete frames so I can process or export them individually."
  },
  {
    "title": "Image colorization",
    "command": "-colorize value",
    "input_type": {},
    "description": "Colorize the image by applying a tint using the specified fill color.",
    "example": "convert input -fill blue -colorize 50% output",
    "intent": "I want to apply a tint to the image using a fill color (e.g., make the image bluish)."
  },
  {
    "title": "Color matrix",
    "command": "-color-matrix matrix",
    "input_type": {},
    "description": "Apply color correction based on a custom matrix.",
    "example": "convert input -color-matrix '1.2,0,0,0,1,0,0,0,1' output",
    "intent": "I want to adjust/correct the image colors by applying a custom transformation matrix."
  },
  {
    "title": "Reduce number of colors",
    "command": "-colors value",
    "input_type": {},
    "description": "Specifies the preferred number of colors in the final image (quantization).",
    "example": "convert input -colors 16 output",
    "intent": "I want to reduce/limit the number of colors in the image to produce a fixed-color version."
  },
  {
    "title": "Colorspace",
    "command": "-colorspace type",
    "input_type": {},
    "description": "Change the image colorspace (RGB, CMYK, Gray, HSL, etc.).",
    "example": "convert input -colorspace Gray output",
    "intent": "I want to change the image colorspace (e.g., switch to grayscale, RGB, or CMYK) to alter how colors are represented."
  },
  {
    "title": "Combine images",
    "command": "-combine",
    "input_type": {},
    "description": "Combine multiple images (or separate channels) into a single composite image.",
    "example": "convert red.png green.png blue.png -combine output.png",
    "intent": "I want to merge/combine multiple images or channels into a single composite image."
  },
  {
    "title": "Add comment",
    "command": "-comment string",
    "input_type": {},
    "description": "Add a text comment to the image metadata.",
    "example": "convert input -comment 'Photo prise à Paris' output",
    "intent": "I want to add a text comment/annotation to the image metadata."
  },
  {
    "title": "Compare images",
    "command": "-compare",
    "input_type": {},
    "description": "Compare two images and generate a difference image highlighting variations.",
    "example": "compare image1.png image2.png diff.png",
    "intent": "I want to compare two images and get an image that clearly shows the differences or variations between them."
  },
  {
    "title": "Complex mathematical operation",
    "command": "-complex operator",
    "input_type": {},
    "description": "Performs complex mathematical operations on a sequence of images (addition, multiplication, conjugation, etc.).",
    "example": "convert img1.png img2.png -complex multiply output.png",
    "intent": "I want to apply a complex mathematical operation between images (addition, multiplication, conjugation, etc.) to obtain a combined result."
  },
  {
    "title": "Composition operator",
    "command": "-compose operator",
    "input_type": {},
    "description": "Sets the operator used to composite multiple images (over, multiply, screen, etc.).",
    "example": "convert img1.png img2.png -compose multiply -composite output.png",
    "intent": "I want to choose the composition operator that determines how two images are blended (e.g., over, multiply, screen)."
  },
  {
    "title": "Image compositing",
    "command": "-composite",
    "input_type": {},
    "description": "Overlay one image onto another using the operator defined by -compose.",
    "example": "convert background.png overlay.png -compose over -composite output.png",
    "intent": "I want to overlay one image onto another using the chosen composition operator to produce a final combined image."
  },
  {
    "title": "contrast enhancement",
    "command": "-contrast",
    "description": "Increases or decreases the image's overall contrast.",
    "example": "convert input -contrast output",
    "intent": "I want to increase or decrease the image's overall contrast to make it appear stronger or softer.",
    "input_type": {}
  },
  {
    "title": "image convolution",
    "command": "-convolve coefficients",
    "description": "Applies a custom convolution kernel to the image (blur, edge detection, etc.).",
    "example": "convert input -convolve '1,1,1,1,8,1,1,1,1' output",
    "intent": "I want to apply a custom convolution kernel (e.g. blur/edge detection) to alter edges or sharpness.",
    "input_type": {}
  },
  {
    "title": "copy region",
    "command": "-copy geometry offset",
    "description": "Copies pixels from one area of the image to another position.",
    "example": "convert input -copy 100x100+10+10+200+200 output",
    "intent": "I want to copy/duplicate an area of the image from one location to another to reposition or clone part of the image.",
    "input_type": {}
  },
  {
    "title": "image cropping",
    "command": "-crop geometry",
    "description": "Cuts out part of the image according to the specified geometry (width x height + offsets).",
    "example": "convert input -crop 400x300+50+50 output",
    "intent": "I want to crop the image to keep only a specific area (size and position) and remove the rest.",
    "input_type": {}
  },
  {
    "title": "colormap rotation",
    "command": "-cycle amount",
    "description": "Rotates the image's colormap by a specified number of steps.",
    "example": "convert input -cycle 10 output",
    "intent": "I want to shift/rotate the image's color palette by a number of steps to change the color appearance.",
    "input_type": {}
  },
  {
    "title": "image decryption",
    "command": "-decipher filename",
    "description": "Converts an image's encrypted pixels back to normal pixels using the provided key.",
    "example": "convert input -decipher key.txt output",
    "intent": "I want to decrypt an encrypted image using the provided key file to recover a readable image.",
    "input_type": {}
  },
  {
    "title": "debug mode",
    "command": "-debug events",
    "description": "Displays detailed debugging information for diagnosing executed commands.",
    "example": "convert input -debug All output",
    "intent": "I want to display detailed debug information to diagnose or understand what the command is doing.",
    "input_type": {}
  },
  {
    "title": "format option definition",
    "command": "-define format:option",
    "description": "Sets one or more file-format-specific options (e.g., compression or metadata).",
    "example": "convert input -define jpeg:extent=200kb output.jpg",
    "intent": "I want to set a specific option for the output format (e.g., compression/size limit or metadata) to control the exported file's characteristics.",
    "input_type": {}
  },
  {
    "title": "sequence deconstruction",
    "command": "-deconstruct",
    "description": "Breaks a sequence of images into its constituent parts, useful for animations.",
    "example": "convert animation.gif -deconstruct frames_%03d.png",
    "intent": "I want to deconstruct an animation or sequence into individual frames to extract each image separately.",
    "input_type": {}
  },
  {
    "title": "frame delay",
    "command": "-delay centiseconds",
    "description": "Specifies the wait time (in hundredths of a second) before displaying the next image in an animation.",
    "example": "convert frames/*.png -delay 10 animation.gif",
    "intent": "I want to set how long each frame is displayed in an animation / define the interval between frames.",
    "input_type": {}
  },
  {
    "title": "delete an image",
    "command": "-delete index",
    "description": "Deletes a given image (by its index) from a sequence of images.",
    "example": "convert animation.gif -delete 0 output.gif",
    "intent": "I want to remove a specific image from a sequence or animation by specifying its index.",
    "input_type": {}
  },
  {
    "title": "image density",
    "command": "-density geometry",
    "description": "Specifies the horizontal and vertical density (DPI) used to read or write an image.",
    "example": "convert input -density 300 output.pdf",
    "intent": "I want to set the density (DPI) used when reading or saving an image / control the resolution during export.",
    "input_type": {}
  },
  {
    "title": "color depth",
    "command": "-depth value",
    "description": "Sets the bit depth per channel for the image (8, 16, 32 bits).",
    "example": "convert input -depth 8 output",
    "intent": "I want to set the image color depth (bits per channel).",
    "input_type": {}
  },
  {
    "title": "despeckle (noise reduction)",
    "command": "-despeckle",
    "description": "Reduces small specks and artifacts (spots) present in a noisy image.",
    "example": "convert input -despeckle output",
    "intent": "I want to reduce small specks/artifacts and visible noise in an image.",
    "input_type": {}
  },
  {
    "title": "text direction",
    "command": "-direction type",
    "description": "Sets the rendering direction of text (LeftToRight or RightToLeft).",
    "example": "convert input -gravity Center -direction RightToLeft -annotate 0 'مرحبا' output",
    "intent": "I want to set the text display/rendering direction (left-to-right / right-to-left).",
    "input_type": {}
  },
  {
    "title": "X server display",
    "command": "-display server",
    "description": "Retrieves an image or a font from a specified X server (Unix/Linux).",
    "example": "convert -display :0 input output",
    "intent": "I want to load or retrieve an image or font from a specified X server.",
    "input_type": {}
  },
  {
    "title": "layer disposal method",
    "command": "-dispose method",
    "description": "Sets the method used to dispose or replace frames in an animation (None, Previous, Background, etc.).",
    "example": "convert frames/*.png -dispose Previous output.gif",
    "intent": "I want to choose how each frame replaces or is removed between animation layers (none / previous / background, etc.).",
    "input_type": {}
  },
  {
    "title": "distributed cache",
    "command": "-distribute-cache port",
    "description": "Starts a distributed pixel cache server to speed up processing of large images.",
    "example": "convert input -distribute-cache 4000 output",
    "intent": "I want to start a distributed pixel cache server on a given port to speed up processing of large images.",
    "input_type": {}
  },
  {
    "title": "image distortion",
    "command": "-distort type coefficients",
    "description": "Applies a geometric transformation (distortion) to the image according to the chosen type (Perspective, Barrel, etc.).",
    "example": "convert input -distort Perspective '0,0 0,0  0,100 10,100  100,0 100,10  100,100 110,110' output",
    "intent": "I want to apply a geometric transformation (e.g., perspective, barrel) to warp the image's appearance.",
    "input_type": {}
  },
  {
    "title": "dithering (dither)",
    "command": "-dither method",
    "description": "Applies error diffusion or ordered dithering to reduce color depth more smoothly.",
    "example": "convert input -dither FloydSteinberg -colors 16 output",
    "intent": "I want to reduce the number of colors in the image using dithering/error diffusion to preserve a smoother appearance.",
    "input_type": {}
  },
  {
    "title": "vector drawing",
    "command": "-draw string",
    "description": "Draws a shape or text on the image using graphic primitives (line, circle, rectangle, text...).",
    "example": "convert input -draw 'circle 100,100 100,50' output",
    "intent": "I want to add or draw shapes and text directly onto the image (lines, circles, rectangles, text...).",
    "input_type": {}
  },
  {
    "title": "image duplication",
    "command": "-duplicate count,indexes",
    "description": "Duplicates one or more images in a sequence a specified number of times.",
    "example": "convert animation.gif -duplicate 2,0 output.gif",
    "intent": "I want to duplicate one or more images in a sequence a certain number of times.",
    "input_type": {}
  },
  {
    "title": "edge detection",
    "command": "-edge radius",
    "description": "Applies an edge-detection filter based on the specified radius.",
    "example": "convert input -edge 1 output",
    "intent": "I want to emphasize the image edges by applying an edge-detection filter.",
    "input_type": {}
  },
  {
    "title": "emboss effect",
    "command": "-emboss radius",
    "description": "Simulates a relief effect on the image by creating a 3D embossing.",
    "example": "convert input -emboss 2 output",
    "intent": "I want to give the image a relief/emboss effect so it appears three-dimensional.",
    "input_type": {}
  },
  {
    "title": "image enciphering",
    "command": "-encipher filename",
    "description": "Converts an image's raw pixels into encrypted pixels using a key.",
    "example": "convert input -encipher key.txt output",
    "intent": "I want to encrypt the image with a key to protect its content.",
    "input_type": {}
  },
  {
    "title": "text encoding",
    "command": "-encoding type",
    "description": "Specifies the text encoding type (UTF8, Latin1, etc.) for text rendering or metadata.",
    "example": "convert input -encoding UTF8 -annotate +10+10 'Café' output",
    "intent": "I want to specify the text encoding (UTF8, Latin1...) so text or metadata displays correctly.",
    "input_type": {}
  },
  {
    "title": "endianness (endianess)",
    "command": "-endian type",
    "description": "Sets the byte order (MSB or LSB) used for reading/writing image data.",
    "example": "convert input -endian MSB output",
    "intent": "I want to choose the byte order (MSB/LSB) used to read/write the image to ensure compatibility with other systems.",
    "input_type": {}
  },
  {
    "title": "image enhancement",
    "command": "-enhance",
    "description": "Applies a digital filter to enhance a noisy image.",
    "example": "convert input -enhance output",
    "intent": "I want to improve a noisy image's quality by applying a filter to reduce noise and clarify the image.",
    "input_type": {}
  },
  {
    "title": "histogram equalization",
    "command": "-equalize",
    "description": "Balances the distribution of pixel intensities to improve overall contrast.",
    "example": "convert input -equalize output",
    "intent": "I want to improve the image's overall contrast by balancing pixel brightness (histogram equalization).",
    "input_type": {}
  },
  {
    "title": "evaluate operation",
    "command": "-evaluate operator value",
    "description": "Evaluates an arithmetic or logical expression on the image pixels (add, multiply, AND, etc.).",
    "example": "convert input -evaluate multiply 1.2 output",
    "intent": "I want to apply an operation (addition, multiplication, AND, etc.) to the image pixels to modify their values.",
    "input_type": {}
  },
  {
    "title": "sequence evaluation",
    "command": "-evaluate-sequence operator",
    "description": "Applies a mathematical or logical operation across a sequence of images (min, max, mean...).",
    "example": "convert frames/*.png -evaluate-sequence mean output.png",
    "intent": "I want to combine multiple images by computing a per-pixel value (mean / minimum / maximum) to produce a single image.",
    "input_type": {}
  },
  {
    "title": "extent (adjust canvas size)",
    "command": "-extent geometry",
    "description": "Adjusts the image canvas size without resizing the content, adding background as needed.",
    "example": "convert input -background white -extent 800x600 output",
    "intent": "I want to change the canvas size without resizing the content, adding background or margins if necessary.",
    "input_type": {}
  },
  {
    "title": "region extraction",
    "command": "-extract geometry",
    "description": "Extracts a specific region of the image according to the given geometry.",
    "example": "convert input -extract 200x200+100+100 output",
    "intent": "I want to extract/crop a precise area of the image (size and position) to keep only that part.",
    "input_type": {}
  },
  {
    "title": "font (family)",
    "command": "-family name",
    "description": "Sets the font family used for rendering text.",
    "example": "convert input -family 'Arial' -pointsize 20 -annotate +10+30 'Hello' output",
    "intent": "I want to choose the font family (for example Arial) used for text added or displayed on the image.",
    "input_type": {}
  },
  {
    "title": "feature analysis",
    "command": "-features distance",
    "description": "Analyzes statistical features of the image such as contrast or correlation.",
    "example": "convert input -features 1.5 output",
    "intent": "I want to analyze statistical characteristics of the image (contrast, correlation, etc.) to obtain measurements about its content.",
    "input_type": {}
  },
  {
    "title": "Fourier transform (FFT)",
    "command": "-fft",
    "description": "Applies the discrete Fourier transform (DFT) to analyze the image's frequency components.",
    "example": "convert input -fft output",
    "intent": "I want to apply a Fourier transform to analyze frequencies and periodic patterns present in the image.",
    "input_type": {}
  },
  {
    "title": "fill color",
    "command": "-fill color",
    "description": "Sets the color used to fill drawn shapes or annotated areas.",
    "example": "convert input -fill red -draw 'rectangle 10,10 200,200' output",
    "intent": "I want to set the fill color (for example red) used to draw or annotate shapes on the image.",
    "input_type": {}
  },
  {
    "title": "resize filter",
    "command": "-filter type",
    "description": "Specifies the filter used when resizing (Lanczos, Gaussian, Mitchell...).",
    "example": "convert input -filter Lanczos -resize 800x600 output",
    "intent": "I want to choose the resize filter (Lanczos, Gaussian, Mitchell...) to control quality when changing the image size.",
    "input_type": {}
  },
  {
    "title": "flatten layers",
    "command": "-flatten",
    "description": "Merges all layers or images in a sequence into a single flat image.",
    "example": "convert frames/*.png -flatten output.png",
    "intent": "I want to merge/flatten all layers or images of a sequence into one flat image to obtain a combined result.",
    "input_type": {}
  },
  {
    "title": "vertical flip",
    "command": "-flip",
    "description": "Flips the image vertically (top ↔ bottom).",
    "example": "convert input -flip output",
    "input_type": {},
    "intent": "I want to flip the image vertically to invert the top and bottom."
  },
  {
    "title": "floodfill (area fill)",
    "command": "-floodfill geometry color",
    "description": "Fills a contiguous area with a specified color starting from a given position.",
    "example": "convert input -floodfill +10+10 blue output",
    "input_type": {},
    "intent": "I want to fill a contiguous area starting at a specific point with a chosen color."
  },
  {
    "title": "horizontal flip",
    "command": "-flop",
    "description": "Flips the image horizontally (left ↔ right).",
    "example": "convert input -flop output",
    "input_type": {},
    "intent": "I want to flip the image horizontally to swap left and right."
  },
  {
    "title": "font selection",
    "command": "-font name",
    "description": "Sets the font used for text added to the image.",
    "example": "convert input -font 'Times-New-Roman' -pointsize 24 -annotate +30+30 'Texte' output",
    "input_type": {},
    "intent": "I want to choose/set the font used for the text I add to the image."
  },
  {
    "title": "formatted information",
    "command": "-format string",
    "description": "Displays or exports formatted information about the image (format, size, colors...).",
    "example": "identify -format '%m %wx%h %z-bit\\n' input",
    "input_type": {},
    "intent": "I want to display or extract formatted information about the image (format, dimensions, color depth, etc.)."
  },
  {
    "title": "decorative frame",
    "command": "-frame geometry",
    "description": "Adds an ornamental frame around the image.",
    "example": "convert input -frame 10x10+2+2 output",
    "input_type": {},
    "intent": "I want to add a decorative frame or border around the image to embellish it."
  },
  {
    "title": "function application",
    "command": "-function name",
    "description": "Applies a mathematical function to the image (Sinusoid, Polynomial, Arcsin...).",
    "example": "convert input -function Sinusoid 3x0.5 output",
    "input_type": {},
    "intent": "I want to apply a mathematical function to the image to create a visual effect (e.g., waves with Sinusoid)."
  },
  {
    "title": "color tolerance (fuzz)",
    "command": "-fuzz distance",
    "description": "Sets a color comparison tolerance: colors within this distance are considered equal.",
    "example": "convert input -fuzz 10% -fill white -opaque red output",
    "input_type": {},
    "intent": "I want to adjust color tolerance so similar shades are treated as identical (useful for replacing/removing an approximate color)."
  },
  {
    "title": "mathematical expression (fx)",
    "command": "-fx expression",
    "description": "Applies a mathematical expression to one or more channels of the image.",
    "example": "convert input -fx 'r*0.8, g, b' output",
    "input_type": {},
    "intent": "I want to apply a mathematical formula to image channels to modify color appearance or intensity."
  },
  {
    "title": "gamma correction",
    "command": "-gamma value",
    "description": "Adjusts overall brightness by modifying the image's gamma curve.",
    "example": "convert input -gamma 1.2 output",
    "input_type": {},
    "intent": "I want to adjust the image's overall brightness by changing its gamma curve."
  },
  {
    "title": "Gaussian blur",
    "command": "-gaussian-blur geometry",
    "input_type": {},
    "description": "Applies a Gaussian blur to reduce noise and soften details.",
    "example": "convert input -gaussian-blur 0x3 output",
    "intent": "I want to soften the image or blur details to reduce noise."
  },
  {
    "title": "Image geometry",
    "command": "-geometry geometry",
    "input_type": {},
    "description": "Specifies the preferred size or position of the image for certain operations.",
    "example": "convert input -geometry 800x600 output",
    "intent": "I want to resize or position the image to a precise size or location."
  },
  {
    "title": "Text gravity",
    "command": "-gravity type",
    "input_type": {},
    "description": "Controls the horizontal and vertical anchoring of text or drawn elements (North, Center, South...).",
    "example": "convert input -gravity SouthEast -annotate +10+10 '© 2025' output",
    "intent": "I want to position or align text or an element (e.g., bottom-right) on the image."
  },
  {
    "title": "Grayscale conversion",
    "command": "-grayscale method",
    "input_type": {},
    "description": "Converts the image to grayscale using a method (Brightness, Lightness, Average...).",
    "example": "convert input -grayscale Average output",
    "intent": "I want to convert the image to grayscale (black and white) to remove colors."
  },
  {
    "title": "Green primary",
    "command": "-green-primary point",
    "input_type": {},
    "description": "Defines the green primary chromaticity point in the color space.",
    "example": "convert input -green-primary 0.3,0.6 output",
    "intent": "I want to define the green reference in the color space to control color reproduction."
  },
  {
    "title": "Help (manual)",
    "command": "-help",
    "input_type": {},
    "description": "Displays the full list of available options and commands.",
    "example": "magick -help",
    "intent": "I want to display the help/manual to see the available options."
  },
  {
    "title": "Hough line detection",
    "command": "-hough-lines geometry",
    "input_type": {},
    "description": "Identifies lines present in an image using the Hough transform.",
    "example": "convert input -hough-lines 20x10 output",
    "intent": "I want to detect straight lines in the image."
  },
  {
    "title": "Image identification",
    "command": "-identify",
    "input_type": {},
    "description": "Displays the main characteristics of the image file (format, size, colors, etc.).",
    "example": "identify input.png",
    "intent": "I want to view the image's technical information (format, size, color depth, etc.)."
  },
  {
    "title": "Inverse Fourier transform",
    "command": "-ift",
    "input_type": {},
    "description": "Applies the inverse Fourier transform to return to the spatial domain.",
    "example": "convert input -ift output",
    "intent": "I want to reconstruct the image from its frequency representation (back to the spatial domain)."
  },
  {
    "title": "Reference illuminant",
    "command": "-illuminant type",
    "input_type": {},
    "description": "Specifies the reference illuminant used for color management (D50, D65, etc.).",
    "example": "convert input -illuminant D65 output",
    "intent": "I want to choose the reference illuminant (e.g., D65) to adjust color management."
  },
  {
    "title": "image implosion",
    "command": "-implode amount",
    "description": "Implodes or explodes image pixels toward or away from the image center by the specified amount.",
    "example": "convert input -implode 0.5 output",
    "intent": "I want to pull or push pixels toward/from the image center to create a distortion effect (implosion/expansion).",
    "input_type": {}
  },
  {
    "title": "image insertion",
    "command": "-insert index",
    "description": "Inserts the last image at a specified position within an image sequence.",
    "example": "convert img1.png img2.png -insert 0 output.gif",
    "intent": "I want to insert/place the last image at a specific position in an image sequence.",
    "input_type": {}
  },
  {
    "title": "integral image",
    "command": "-integral",
    "description": "Computes the cumulative sum of pixel values in the image (integral image).",
    "example": "convert input -integral output",
    "intent": "I want to create an integral image that contains the cumulative sums of pixel values.",
    "input_type": {}
  },
  {
    "title": "pixel intensity",
    "command": "-intensity method",
    "description": "Sets the method used to compute a pixel's intensity (Average, Lightness, etc.).",
    "example": "convert input -intensity Average -grayscale Rec709Luminance output",
    "intent": "I want to choose/set the method for computing pixel intensity (e.g., average, lightness) to adjust grayscale conversion.",
    "input_type": {}
  },
  {
    "title": "rendering intent",
    "command": "-intent type",
    "description": "Specifies the rendering intent for color management (Perceptual, Relative, etc.).",
    "example": "convert input -intent Perceptual output",
    "intent": "I want to specify the rendering intent (perceptual/relative/etc.) to control how colors are handled during conversions.",
    "input_type": {}
  },
  {
    "title": "image interlacing",
    "command": "-interlace type",
    "description": "Sets the interlace scheme for the output file (None, Line, Plane, Partition).",
    "example": "convert input -interlace Line output.jpg",
    "intent": "I want to choose the output file interlace type (none/line/plane/partition) to control how the image loads/displays progressively.",
    "input_type": {}
  },
  {
    "title": "interline spacing",
    "command": "-interline-spacing value",
    "description": "Sets the spacing between lines of text.",
    "example": "convert input -interline-spacing 5 -annotate +10+50 'Texte multi-ligne' output",
    "intent": "I want to adjust the vertical spacing between lines of text (leading) to tweak layout.",
    "input_type": {}
  },
  {
    "title": "pixel interpolation",
    "command": "-interpolate method",
    "description": "Selects the pixel color interpolation method (Nearest, Bilinear, Bicubic, etc.).",
    "example": "convert input -interpolate Bicubic output",
    "intent": "I want to choose the pixel interpolation method (Nearest/Bilinear/Bicubic, etc.) to control quality during resizing or transformations.",
    "input_type": {}
  },
  {
    "title": "interword spacing",
    "command": "-interword-spacing value",
    "description": "Sets the horizontal spacing between words in text.",
    "example": "convert input -interword-spacing 4 -annotate +10+20 'Hello world' output",
    "intent": "I want to adjust horizontal spacing between words to change the text appearance.",
    "input_type": {}
  },
  {
    "title": "kerning",
    "command": "-kerning value",
    "description": "Adjusts the spacing between characters in text.",
    "example": "convert input -kerning 2 -annotate +20+50 'TEXTE' output",
    "intent": "I want to adjust character spacing (kerning) to improve text appearance.",
    "input_type": {}
  },
  {
    "title": "Kuwahara filter",
    "command": "-kuwahara geometry",
    "description": "Applies a smoothing filter that preserves edges while reducing noise.",
    "example": "convert input -kuwahara 0x5 output",
    "intent": "I want to smooth/reduce noise in an image without removing important edges.",
    "input_type": {}
  },
  {
    "title": "Add label",
    "command": "-label string",
    "description": "Assigns a label to the image for identification or metadata.",
    "example": "convert input -label 'Carte n°42' output",
    "intent": "I want to add a label/name to an image to identify it or store information.",
    "input_type": {}
  },
  {
    "title": "Local Adaptive Threshold (LAT)",
    "command": "-lat geometry",
    "description": "Applies a local adaptive threshold to improve contrast in dark areas.",
    "example": "convert input -lat 10x10+5% output",
    "intent": "I want to improve local contrast, especially in dark regions, by applying adaptive thresholding on small areas.",
    "input_type": {}
  },
  {
    "title": "Layer management",
    "command": "-layers method",
    "description": "Optimizes, compares, or manipulates the layers of an image sequence.",
    "example": "convert frames/*.png -layers optimize output.gif",
    "intent": "I want to manage/optimize the layers of an image or sequence (e.g., to reduce GIF size or compare differences between layers).",
    "input_type": {}
  },
  {
    "title": "Level adjustment",
    "command": "-level value",
    "description": "Adjusts input/output levels and gamma to modify overall contrast.",
    "example": "convert input -level 10%,90%,1.2 output",
    "intent": "I want to adjust levels and gamma to correct overall image contrast and brightness.",
    "input_type": {}
  },
  {
    "title": "Resource limits",
    "command": "-limit type value",
    "description": "Sets a limit on resource usage (memory, map, disk, etc.) during processing.",
    "example": "convert input -limit memory 512MiB output",
    "intent": "I want to limit the amount of resources (memory, disk, etc.) used during image processing.",
    "input_type": {}
  },
  {
    "title": "Linear stretch",
    "command": "-linear-stretch geometry",
    "description": "Performs a linear histogram stretch with saturation of extreme values.",
    "example": "convert input -linear-stretch 2%x1% output",
    "intent": "I want to stretch an image's histogram to increase contrast while slightly saturating extreme values.",
    "input_type": {}
  },
  {
    "title": "Liquid rescale (seam carving)",
    "command": "-liquid-rescale geometry",
    "description": "Intelligently resizes an image while preserving important elements (seam carving).",
    "example": "convert input -liquid-rescale 800x600 output",
    "intent": "I want to resize an image intelligently to keep important elements without distorting them (seam carving).",
    "input_type": {}
  },
  {
    "title": "List resources",
    "command": "-list type",
    "description": "Displays a list of ImageMagick internal items (formats, modules, resources, etc.).",
    "example": "-list format",
    "intent": "I want to display the list of formats/modules/resources available in ImageMagick.",
    "input_type": {}
  },
  {
    "title": "Logging (log)",
    "command": "-log format",
    "description": "Specifies the format of debug or logging messages.",
    "example": "convert input -log '%t: %e' output",
    "intent": "I want to set the format of logging/debug messages to better read and understand the logs.",
    "input_type": {}
  },
  {
    "title": "GIF animation loop",
    "command": "-loop iterations",
    "description": "Adds a Netscape extension to loop a GIF animation a specified number of times.",
    "example": "convert frames/*.png -loop 0 animation.gif",
    "input_type": {},
    "intent": "I want my GIF to repeat a certain number of times / loop."
  },
  {
    "title": "image masking",
    "command": "-mask filename",
    "description": "Associates a pixel mask with the image to restrict changes to specific areas.",
    "example": "convert input -mask mask.png -blur 0x5 output",
    "input_type": {},
    "intent": "I want to apply a mask to limit edits to certain areas / preserve the rest of the image."
  },
  {
    "title": "frame (matte) color",
    "command": "-mattecolor color",
    "description": "Sets the border color used for frames or transparent backgrounds.",
    "example": "convert input -mattecolor black -frame 10x10 output",
    "input_type": {},
    "intent": "I want to set the border/frame color or the transparent background color."
  },
  {
    "title": "median filter",
    "command": "-median radius",
    "description": "Applies a median filter to reduce noise while preserving edges.",
    "example": "convert input -median 2 output",
    "input_type": {},
    "intent": "I want to reduce image noise while preserving contours / smooth without excessively blurring details."
  },
  {
    "title": "mean-shift segmentation",
    "command": "-mean-shift geometry",
    "description": "Defines arbitrarily-shaped regions by grouping similar pixels.",
    "example": "convert input -mean-shift 10x10 output",
    "input_type": {},
    "intent": "I want to group similar pixels to delineate homogeneous regions / detect areas of color or texture."
  },
  {
    "title": "comparison metric",
    "command": "-metric type",
    "description": "Sets the metric used to compare two images (RMSE, PSNR, SSIM...).",
    "example": "compare -metric RMSE img1.png img2.png diff.png",
    "input_type": {},
    "intent": "I want to measure the difference between two images using a metric (e.g., RMSE, PSNR, SSIM)."
  },
  {
    "title": "predominant color mode",
    "command": "-mode radius",
    "description": "Replaces each pixel with the most frequent color in its neighborhood.",
    "example": "convert input -mode 3 output",
    "input_type": {},
    "intent": "I want to replace each pixel with the most frequent color in its neighborhood to simplify/unify color areas."
  },
  {
    "title": "HSL modulation",
    "command": "-modulate value",
    "description": "Adjusts the image's brightness, saturation, and hue.",
    "example": "convert input -modulate 110,90,100 output",
    "input_type": {},
    "intent": "I want to adjust brightness, saturation, and hue (e.g., brighten, darken, increase or decrease saturation)."
  },
  {
    "title": "image moments",
    "command": "-moments",
    "description": "Displays the image's statistical moments (centroid, dispersion, orientation...).",
    "example": "convert input -moments output",
    "input_type": {},
    "intent": "I want statistical measurements of the image (center, dispersion, orientation) to analyze its shape."
  },
  {
    "title": "progress monitoring",
    "command": "-monitor",
    "description": "Displays image processing progress in the console.",
    "example": "convert input -monitor -resize 50% output",
    "input_type": {},
    "intent": "I want to monitor image processing progress in the console / see real-time progress."
  },
  {
    "title": "black and white conversion",
    "command": "-monochrome",
    "description": "Converts the image to pure black and white (binary).",
    "example": "convert input -monochrome output",
    "intent": "I want to convert the image to pure black and white (binary) to have only black and white — a two-tone, drawing-like result.",
    "input_type": {}
  },
  {
    "title": "image morphing",
    "command": "-morph value",
    "description": "Creates a sequence of intermediate images between two images.",
    "example": "convert img1.png img2.png -morph 10 morph_%02d.png",
    "intent": "I want to generate a series of intermediate images between two images to create a morphing transition/sequence.",
    "input_type": {}
  },
  {
    "title": "image morphology",
    "command": "-morphology method kernel",
    "description": "Applies a morphological operation (Erode, Dilate, Open, Close, etc.) with a given kernel.",
    "example": "convert input -morphology Dilate Diamond output",
    "intent": "I want to apply a morphological operation (erosion, dilation, opening, closing, etc.) with a specific kernel to modify shapes or visible details in the image.",
    "input_type": {}
  },
  {
    "title": "motion blur",
    "command": "-motion-blur geometry",
    "description": "Simulates a directional (motion) blur effect.",
    "example": "convert input -motion-blur 0x10+30 output",
    "intent": "I want to add directional motion blur to convey movement or simulate speed.",
    "input_type": {}
  },
  {
    "title": "color inversion",
    "command": "-negate",
    "description": "Inverts the image colors (creates a negative).",
    "example": "convert input -negate output",
    "intent": "I want to invert the image colors to obtain its negative.",
    "input_type": {}
  },
  {
    "title": "add or reduce noise",
    "command": "-noise radius",
    "description": "Adds or reduces noise in the image according to the specified radius.",
    "example": "convert input -noise 3 output",
    "intent": "I want to add or reduce noise/grain in the image according to the chosen level (radius).",
    "input_type": {}
  },
  {
    "title": "color normalization",
    "command": "-normalize",
    "description": "Expands the color range to use the full available range.",
    "example": "convert input -normalize output",
    "intent": "I want to expand the image's color range to use the full available range, improving tone distribution and contrast.",
    "input_type": {}
  },
  {
    "title": "color replacement",
    "command": "-opaque color",
    "description": "Replaces a specific color with the fill color defined via -fill.",
    "example": "convert input -fill blue -opaque red output",
    "intent": "I want to replace a specific color in the image with another color of my choice (for example, change all red to blue).",
    "input_type": {}
  },
  {
    "title": "ordered dithering",
    "command": "-ordered-dither NxN",
    "description": "Applies ordered dithering to the image using an NxN matrix.",
    "example": "convert input -ordered-dither 4x4 output",
    "intent": "I want to apply ordered dithering with an NxN matrix to reduce colors into regular patterns or achieve a stippled/patterned look.",
    "input_type": {}
  },
  {
    "title": "image orientation",
    "command": "-orient type",
    "description": "Sets or changes the image's EXIF orientation.",
    "example": "convert input -orient TopLeft output",
    "intent": "I want to set or correct the image's EXIF orientation so it displays/rotates correctly (e.g., rotate or specify orientation).",
    "input_type": {}
  },
  {
    "title": "canvas (page) size",
    "command": "-page geometry",
    "description": "Defines the size and position of the canvas associated with the image.",
    "example": "convert input -page 800x600+10+10 output",
    "intent": "I want to set the image canvas size and position to place or move the image on a page.",
    "input_type": {}
  },
  {
    "title": "oil paint effect",
    "command": "-paint radius",
    "description": "Simulates an oil painting effect by smoothing color transitions.",
    "example": "convert input -paint 3 output",
    "intent": "I want to apply an oil paint effect to soften color transitions and produce an artistic look.",
    "input_type": {}
  },
  {
    "title": "make perceptible",
    "command": "-perceptible",
    "description": "Forces pixels close to zero to become ±epsilon to make them perceptible.",
    "example": "convert input -perceptible output",
    "intent": "I want to make pixels that are very close to zero visible (make very faint tones slightly detectable).",
    "input_type": {}
  },
  {
    "title": "quick analysis (ping)",
    "command": "-ping",
    "description": "Inspects image metadata without fully loading the image (very fast).",
    "example": "identify -ping input.jpg",
    "intent": "I want to quickly inspect an image's metadata without fully loading it.",
    "input_type": {}
  },
  {
    "title": "font size (points)",
    "command": "-pointsize value",
    "description": "Sets the font size (in typographic points) for text annotations.",
    "example": "convert input -pointsize 24 -annotate +10+30 'Texte' output",
    "intent": "I want to set the font size (in points) for text or annotations.",
    "input_type": {}
  },
  {
    "title": "Polaroid effect",
    "command": "-polaroid angle",
    "description": "Simulates a Polaroid-style photo with rotation and a white border.",
    "example": "convert input -polaroid 5 output",
    "intent": "I want to make the image look like a Polaroid photo with a white border and a slight rotation/tilt.",
    "input_type": {}
  },
  {
    "title": "image polynomial",
    "command": "-poly terms",
    "description": "Builds an image resulting from a polynomial combination of multiple images (coefficients and degrees).",
    "example": "convert img1.png img2.png -poly '1,0.5' output",
    "intent": "I want to combine multiple images into one by mixing their intensities according to coefficients (polynomial combination).",
    "input_type": {}
  },
  {
    "title": "posterize",
    "command": "-posterize levels",
    "description": "Reduces the image to a limited number of color levels for an artistic or retro effect.",
    "example": "convert input -posterize 4 output",
    "intent": "I want to reduce the number of color levels in the image to create an artistic or retro (posterized) effect.",
    "input_type": {}
  },
  {
    "title": "numeric precision",
    "command": "-precision value",
    "description": "Sets the maximum number of significant digits to display in numeric values.",
    "example": "convert input -precision 5 output",
    "intent": "I want to control the displayed precision of numeric values by setting the number of significant digits.",
    "input_type": {}
  },
  {
    "title": "image preview",
    "command": "-preview type",
    "description": "Generates a preview of the image according to the chosen type (Gamma, Histogram, etc.).",
    "example": "convert input -preview Gamma output",
    "intent": "I want to generate a preview/thumbnail of the image for a chosen type (Gamma, histogram, etc.) to quickly visualize its appearance.",
    "input_type": {}
  },
  {
    "title": "console print",
    "command": "-print string",
    "description": "Interprets and displays a text string to the console (useful for debugging).",
    "example": "convert input -print 'Processing done' output",
    "intent": "I want to display a message in the console to monitor or debug the image processing.",
    "input_type": {}
  },
  {
    "title": "custom filter",
    "command": "-process image-filter",
    "description": "Applies a custom filter to the image via an external module.",
    "example": "convert input -process custom-filter output",
    "intent": "I want to apply a custom filter/effect to my image using an external module.",
    "input_type": {}
  },
  {
    "title": "ICC/EXIF profile",
    "command": "-profile filename",
    "description": "Adds, removes, or applies a color profile (ICC, EXIF, etc.) to the image.",
    "example": "convert input -profile sRGB.icc output",
    "intent": "I want to add, replace, or remove the image's color profile (ICC/EXIF) to correct or preserve colors.",
    "input_type": {}
  },
  {
    "title": "image compression",
    "command": "magick input -quality 80 -strip -background white -flatten output",
    "description": "Compresses the image to reduce file size while keeping the same format. Metadata is stripped and transparency is flattened when needed (e.g. for JPEG).",
    "example": "magick input.jpg -quality 80 -strip -background white -flatten output.jpg",
    "intent": "I want to compress the image to make its file size smaller without changing its format.",
    "input_type": {
      "pdf": "magick -density 150 input.pdf -quality 80 -strip -background white -flatten output.pdf",
      "gif": "magick input.gif -coalesce -layers optimize output.gif"
    }
  },
  {
    "title": "color quantization",
    "command": "-quantize colorspace",
    "description": "Reduces the image colors in a given color space (RGB, HSL, etc.).",
    "example": "convert input -quantize RGB -colors 32 output",
    "intent": "I want to reduce the number of colors in the image in a given color space (e.g., RGB) to limit the palette or decrease file size.",
    "input_type": {}
  },
  {
    "title": "quiet mode",
    "command": "-quiet",
    "description": "Suppresses all warnings and informational messages during processing.",
    "example": "convert input -quiet output",
    "intent": "I want to run processing without showing warnings or messages (silent mode).",
    "input_type": {}
  },
  {
    "title": "rotational blur",
    "command": "-rotational-blur angle",
    "description": "Applies a rotational blur around the image center.",
    "example": "convert input -rotational-blur 30 output",
    "intent": "I want to add rotational/radial blur around the center to convey rotating motion.",
    "input_type": {}
  },
  {
    "title": "edge emboss (3D)",
    "command": "-raise value",
    "description": "Lightens or darkens the image edges to create a 3D embossed effect.",
    "example": "convert input -raise 10 output",
    "intent": "I want to create a 3D embossed effect by lightening or darkening the image edges (to simulate a raised or inset border).",
    "input_type": {}
  },
  {
    "title": "random threshold",
    "command": "-random-threshold low,high",
    "description": "Applies a random threshold between two values to create a noisy halftone/dither effect.",
    "example": "convert input -random-threshold 30%,70% output",
    "intent": "I want to apply a random threshold between two values to produce a binary dither/noise pattern on the image.",
    "input_type": {}
  },
  {
    "title": "red primary point",
    "command": "-red-primary point",
    "description": "Sets the chromaticity point of the red primary in the color space.",
    "example": "convert input -red-primary 0.64,0.33 output",
    "intent": "I want to precisely define the red hue used (the red primary chromaticity point) to adjust color reproduction.",
    "input_type": {}
  },
  {
    "title": "treat warnings as errors",
    "command": "-regard-warnings",
    "description": "Make the command fail on warnings, not just on errors.",
    "example": "convert input -regard-warnings output",
    "intent": "I want the command to fail on warnings as well as on errors.",
    "input_type": {}
  },
  {
    "title": "target region",
    "command": "-region geometry",
    "description": "Apply an option only to a specific area of the image.",
    "example": "convert input -region 100x100+50+50 -blur 0x5 output",
    "intent": "I want to apply a modification only to a precise area of the image (a region/portion).",
    "input_type": {}
  },
  {
    "title": "color remapping",
    "command": "-remap filename",
    "description": "Remap the image colors to match a given palette.",
    "example": "convert input -remap palette.png output",
    "intent": "I want my image colors adapted to match a given palette / to use a color palette.",
    "input_type": {}
  },
  {
    "title": "vector rendering",
    "command": "-render",
    "description": "Render vector content (text, paths) before producing the raster output.",
    "example": "convert input.svg -render output.png",
    "intent": "I want vector content (text, paths) rendered correctly before creating the raster image.",
    "input_type": {}
  },
  {
    "title": "canvas reset",
    "command": "-repage geometry",
    "description": "Redefine the size and position of an existing image canvas.",
    "example": "convert input -repage 800x600+0+0 output",
    "intent": "I want to redefine the size and position of my image canvas (change the frame/work area).",
    "input_type": {}
  },
  {
    "title": "change resolution",
    "command": "-resample geometry",
    "description": "Modify the image resolution (DPI) without altering its pixel dimensions.",
    "example": "convert input -resample 300 output",
    "intent": "I want to change the image resolution (DPI) without changing its pixel dimensions.",
    "input_type": {}
  },
  {
    "title": "image reshaping",
    "command": "-reshape geometry",
    "description": "Reshape the image's geometric structure (useful for certain raw formats).",
    "example": "convert input -reshape 800x600 output",
    "intent": "I want to reshape the image geometry, for example to adapt raw data to a new layout.",
    "input_type": {}
  },
  {
    "title": "resize",
    "command": "-resize geometry",
    "description": "Resize the image to the desired dimensions using interpolation.",
    "example": "convert input -resize 800x600 output",
    "intent": "I want to change the image size (enlarge/reduce) to reach precise dimensions.",
    "input_type": {}
  },
  {
    "title": "respect parentheses",
    "command": "-respect-parentheses",
    "description": "Keep settings active only within a parenthesized group.",
    "example": "convert ( input -blur 0x3 ) output",
    "intent": "I want certain settings to apply only inside a parenthesized group to isolate effects.",
    "input_type": {}
  },
  {
    "title": "roll (scroll)",
    "command": "-roll geometry",
    "description": "Scroll the image horizontally or vertically by a specified offset.",
    "example": "convert input -roll +100+0 output",
    "intent": "I want to roll/scroll the image horizontally or vertically by a given offset.",
    "input_type": {}
  },
  {
    "title": "image rotation",
    "command": "-rotate degrees",
    "description": "Rotates the image by the specified angle (in degrees, clockwise).",
    "example": "convert input -rotate 90 output",
    "input_type": {},
    "intent": "I want to rotate the image to the left (270) or to the right (90) by a specified number of degrees to change its orientation."
  },
  {
    "title": "pixel sampling",
    "command": "-sample geometry",
    "description": "Resizes the image using simple pixel resampling (no interpolation).",
    "example": "convert input -sample 400x400 output",
    "input_type": {},
    "intent": "I want to resize the image by resampling pixels without smoothing/interpolation for a raw, fast result."
  },
  {
    "title": "sampling factor",
    "command": "-sampling-factor geometry",
    "description": "Sets the horizontal and vertical sampling factors (commonly used for JPEG).",
    "example": "convert input -sampling-factor 2x1 output",
    "input_type": {},
    "intent": "I want to adjust how colors are subsampled horizontally and vertically (useful for JPEG encoding)."
  },
  {
    "title": "scaling",
    "command": "-scale geometry",
    "description": "Scales the image in a simple way (equivalent to a fast resize).",
    "example": "convert input -scale 50% output",
    "input_type": {},
    "intent": "I want to scale the image (up or down) simply and quickly, e.g., reduce to 50%."
  },
  {
    "title": "scene number",
    "command": "-scene value",
    "description": "Sets the scene number for an image in a sequence (useful for GIFs or multi-page TIFFs).",
    "example": "convert frames/*.png -scene 0 animation.gif",
    "input_type": {},
    "intent": "I want to set the scene/start number for an image in a sequence to create a GIF or multipage file."
  },
  {
    "title": "random seed",
    "command": "-seed value",
    "description": "Initializes the random number generator seed for deterministic processing.",
    "example": "convert input -seed 1234 -noise 2 output",
    "input_type": {},
    "intent": "I want to fix the random seed so that random effects (noise, variations) are reproducible."
  },
  {
    "title": "image segmentation",
    "command": "-segment values",
    "description": "Segments an image into regions based on color or intensity similarity.",
    "example": "convert input -segment 0.5x0.5 output",
    "input_type": {},
    "intent": "I want to segment the image into regions of similar color/tones to isolate areas or objects."
  },
  {
    "title": "selective blur",
    "command": "-selective-blur geometry",
    "description": "Applies blur only to low-contrast areas while preserving sharp edges.",
    "example": "convert input -selective-blur 0x5+10% output",
    "input_type": {},
    "intent": "I want to apply a blur that only affects low-contrast areas to keep edges sharp and reduce noise without blurring edges."
  },
  {
    "title": "channel separation",
    "command": "-separate",
    "description": "Separates the image channels (R, G, B, A...) into distinct grayscale images.",
    "example": "convert input -separate channel_%d.png",
    "input_type": {},
    "intent": "I want to extract each channel (R, G, B, Alpha...) into separate grayscale images."
  },
  {
    "title": "sepia tone",
    "command": "-sepia-tone threshold",
    "description": "Applies a sepia effect to simulate an old photograph.",
    "example": "convert input -sepia-tone 80% output",
    "input_type": {},
    "intent": "I want to give the image a sepia tint / vintage photo effect by adjusting the intensity."
  },
  {
    "title": "image attribute",
    "command": "-set attribute value",
    "description": "Sets an image attribute (e.g., title, author, copyright, etc.).",
    "example": "convert input -set author 'Cyril Mammar' output",
    "intent": "I want to add or modify the image metadata (e.g., title / author / copyright).",
    "input_type": {}
  },
  {
    "title": "shading (distant light)",
    "command": "-shade degrees",
    "description": "Illuminates the image as if lit by a distant light source, creating a relief effect.",
    "example": "convert input -shade 120x30 output",
    "intent": "I want to illuminate the image to give it depth by simulating a distant light source.",
    "input_type": {}
  },
  {
    "title": "drop shadow",
    "command": "-shadow geometry",
    "description": "Creates a drop shadow for the image, simulating depth.",
    "example": "convert input -shadow 80x3+5+5 output",
    "intent": "I want to add a drop shadow to the image to simulate depth/a raised effect.",
    "input_type": {}
  },
  {
    "title": "image sharpening",
    "command": "-sharpen geometry",
    "description": "Improves sharpness by increasing local contrast between pixels.",
    "example": "convert input -sharpen 0x2 output",
    "intent": "I want to sharpen the image to make details crisper and more precise.",
    "input_type": {}
  },
  {
    "title": "edge cropping",
    "command": "-shave geometry",
    "description": "Removes a number of pixels from the edges of the image.",
    "example": "convert input -shave 10x10 output",
    "intent": "I want to trim the edges of the image by removing a margin of pixels.",
    "input_type": {}
  },
  {
    "title": "shear",
    "command": "-shear geometry",
    "description": "Offsets one edge of the image along the X or Y axis to create a shear (skew) effect.",
    "example": "convert input -shear 10x0 output",
    "intent": "I want to skew the image by shifting an edge horizontally or vertically to create a shear effect.",
    "input_type": {}
  },
  {
    "title": "sigmoidal contrast",
    "command": "-sigmoidal-contrast geometry",
    "description": "Increases contrast without clipping highlights and shadows.",
    "example": "convert input -sigmoidal-contrast 5x50% output",
    "intent": "I want to enhance contrast smoothly while preserving detail in highlights and shadows.",
    "input_type": {}
  },
  {
    "title": "image smush",
    "command": "-smush offset",
    "description": "Joins a sequence of images side-by-side or stacked.",
    "example": "convert img1.png img2.png -smush 10 output",
    "intent": "I want to assemble multiple images side-by-side or stacked with a specified spacing.",
    "input_type": {}
  },
  {
    "title": "image size",
    "command": "-size geometry",
    "description": "Specifies the image width and height when creating it.",
    "example": "convert -size 800x600 canvas:white output.png",
    "intent": "I want to create an image at a specific size (width × height), e.g., 800×600.",
    "input_type": {}
  },
  {
    "title": "sketch effect",
    "command": "-sketch geometry",
    "description": "Simulates a pencil drawing from the original image.",
    "example": "convert input -sketch 0x20 output",
    "intent": "I want to convert a photo into a sketch or pencil drawing.",
    "input_type": {}
  },
  {
    "title": "solarization",
    "command": "-solarize threshold",
    "description": "Inverts pixels whose intensity exceeds a given threshold, creating a solarization effect.",
    "example": "convert input -solarize 50% output",
    "intent": "I want to create a solarization effect by inverting pixels that exceed a given threshold / invert overly bright areas.",
    "input_type": {}
  },
  {
    "title": "pixel sorting",
    "command": "-sort-pixels",
    "description": "Sorts the pixels in each row by their brightness.",
    "example": "convert input -sort-pixels output",
    "intent": "I want to sort each row's pixels by intensity to produce an ordered/organized visual effect.",
    "input_type": {}
  },
  {
    "title": "background insertion",
    "command": "-splice geometry",
    "description": "Inserts the background color into the image, offsetting its content.",
    "example": "convert input -background white -splice 10x10 output",
    "intent": "I want to add space filled with the background color (e.g., a border or inset) by shifting the image content.",
    "input_type": {}
  },
  {
    "title": "pixel spread",
    "command": "-spread radius",
    "description": "Randomly displaces the image pixels to create a spreading effect.",
    "example": "convert input -spread 5 output",
    "intent": "I want to create a diffusion/noise effect by randomly displacing pixels for a scattered or textured appearance.",
    "input_type": {}
  },
  {
    "title": "local statistic",
    "command": "-statistic type geometry",
    "description": "Replaces each pixel with the statistic (mean, median, etc.) of its neighbors.",
    "example": "convert input -statistic Mean 5x5 output",
    "intent": "I want to smooth or filter the image by replacing each pixel with the mean, median, or another statistic of its neighbors to reduce noise or achieve a filtering effect.",
    "input_type": {}
  },
  {
    "title": "strip metadata",
    "command": "-strip",
    "description": "Removes all profiles, metadata, and comments from the image.",
    "example": "convert input -strip output",
    "intent": "I want to remove all metadata, profiles, and comments from the image to produce a file without extra information.",
    "input_type": {}
  },
  {
    "title": "stroke color",
    "command": "-stroke color",
    "description": "Sets the stroke color for drawn vector shapes.",
    "example": "convert input -stroke black -strokewidth 2 -draw 'rectangle 10,10 100,100' output",
    "intent": "I want to set or change the stroke color for the shapes I draw (e.g., rectangles, circles).",
    "input_type": {}
  },
  {
    "title": "stroke width",
    "command": "-strokewidth value",
    "description": "Sets the stroke width used for drawn shapes.",
    "example": "convert input -strokewidth 3 -draw 'circle 50,50 50,10' output",
    "intent": "I want to adjust the stroke thickness for drawn shapes to make it thinner or thicker.",
    "input_type": {}
  },
  {
    "title": "font stretch",
    "command": "-stretch type",
    "description": "Sets the text stretch (Normal, Condensed, Expanded, etc.).",
    "example": "convert input -stretch Expanded -annotate +10+10 'Texte' output",
    "intent": "I want to adjust the text stretch (normal, condensed, expanded) to change the appearance of characters.",
    "input_type": {}
  },
  {
    "title": "font style",
    "command": "-style type",
    "description": "Sets the text style (Normal, Italic, Oblique).",
    "example": "convert input -style Italic -annotate +10+10 'Texte' output",
    "intent": "I want to apply a font style (e.g., italic or oblique) to change the text appearance.",
    "input_type": {}
  },
  {
    "title": "swap images",
    "command": "-swap indexes",
    "description": "Swap two images in a sequence by their indexes.",
    "example": "convert img1.png img2.png -swap 0,1 output",
    "intent": "I want to swap the order of two images in a sequence / interchange two images.",
    "input_type": {}
  },
  {
    "title": "swirl (twirl)",
    "command": "-swirl degrees",
    "description": "Swirls the image pixels around its center.",
    "example": "convert input -swirl 90 output",
    "intent": "I want to apply a swirl effect to warp the image into a spiral.",
    "input_type": {}
  },
  {
    "title": "disk synchronization",
    "command": "-synchronize",
    "description": "Force synchronization of the image to disk after writing.",
    "example": "convert input -synchronize output",
    "intent": "I want to force sync of the image to disk to ensure it is written.",
    "input_type": {}
  },
  {
    "title": "mark as modified",
    "command": "-taint",
    "description": "Mark the image as modified to avoid cache reuse.",
    "example": "convert input -taint output",
    "intent": "I want to mark the image as modified to prevent its reuse from the cache.",
    "input_type": {}
  },
  {
    "title": "background texture",
    "command": "-texture filename",
    "description": "Apply a repeating texture as the image background.",
    "example": "convert input -texture texture.png output",
    "intent": "I want to fill the image background with a repeating texture.",
    "input_type": {}
  },
  {
    "title": "binary threshold",
    "command": "-threshold value",
    "description": "Transform pixels according to a threshold: above = white, below = black.",
    "example": "convert input -threshold 50% output",
    "intent": "I want to convert the image to black and white using a threshold (above = white, below = black).",
    "input_type": {}
  },
  {
    "title": "thumbnail",
    "command": "-thumbnail geometry",
    "description": "Create a thumbnail version of the image, optimized for previews.",
    "example": "convert input -thumbnail 200x200 output",
    "intent": "I want to create a thumbnail version of the image for a preview / vignette.",
    "input_type": {}
  },
  {
    "title": "pattern fill",
    "command": "-tile filename",
    "description": "Use an image as a repeated pattern to fill shapes.",
    "example": "convert input -tile pattern.png -draw 'rectangle 0,0 200,200' output",
    "intent": "I want to fill an area or shape with a repeated pattern from an image.",
    "input_type": {}
  },
  {
    "title": "tile offset",
    "command": "-tile-offset geometry",
    "description": "Offset the starting position of the fill pattern.",
    "example": "convert input -tile-offset +10+10 output",
    "intent": "I want to offset the pattern's start position to change the fill alignment.",
    "input_type": {}
  },
  {
    "title": "image tint",
    "command": "-tint value",
    "description": "Apply a colored tint to the image by blending with the fill color.",
    "example": "convert input -fill blue -tint 40% output",
    "intent": "I want to tint the image with a color to give it a visible hue.",
    "input_type": {}
  },
  {
    "title": "Affine transformation",
    "command": "-transform",
    "description": "Applies a full affine transformation (rotation, translation, shear).",
    "example": "convert input -transform output",
    "intent": "I want to apply a transformation to my image, for example rotate, move, or shear it.",
    "input_type": {}
  },
  {
    "title": "Make transparant => Remove background color",
    "command": "-fuzz 10% -transparent white",
    "description": "Removes a uniform background (e.g., white) and makes it transparent. Useful for converting opaque images to PNG with transparency.",
    "example": "magick input.jpg -fuzz 10% -transparent white output.png",
    "intent": "I want to remove the white (or uniform) background and make it transparent.",
    "input_type": {
      "jpg": "magick input.jpg -fuzz 10% -transparent white output.png",
      "jpeg": "magick input.jpeg -fuzz 10% -transparent white output.png",
      "bmp": "magick input.bmp -fuzz 10% -transparent white output.png"
    }
  },
  {
    "title": "Define transparent color",
    "command": "-transparent-color color",
    "description": "Defines the color that will be treated as transparent in certain operations.",
    "example": "convert input -transparent-color white output",
    "intent": "I want to set which color should be considered transparent during subsequent operations.",
    "input_type": {}
  },
  {
    "title": "Image transpose",
    "command": "-transpose",
    "description": "Flips the image vertically then rotates it 90°.",
    "example": "convert input -transpose output",
    "intent": "I want to flip my image vertically then rotate it 90° (flip and rotate).",
    "input_type": {}
  },
  {
    "title": "Image transverse",
    "command": "-transverse",
    "description": "Flips the image horizontally then rotates it 270°.",
    "example": "convert input -transverse output",
    "intent": "I want to flip my image horizontally then rotate it 270° (equivalent to a -90° rotation).",
    "input_type": {}
  },
  {
    "title": "Color tree depth",
    "command": "-treedepth value",
    "description": "Sets the depth of the color tree used for quantization.",
    "example": "convert input -treedepth 8 output",
    "intent": "I want to adjust the color tree depth used to reduce/quantize the image's colors.",
    "input_type": {}
  },
  {
    "title": "Automatic trim",
    "command": "-trim",
    "description": "Automatically removes uniform borders around the image.",
    "example": "convert input -trim output",
    "intent": "I want to automatically remove uniform borders around my image (trim the margins).",
    "input_type": {}
  },
  {
    "title": "Image type",
    "command": "-type type",
    "description": "Specifies the image type (TrueColor, Grayscale, Palette, etc.).",
    "example": "convert input -type Grayscale output",
    "intent": "I want to set the image type (e.g., TrueColor, Grayscale, or Palette) for my file.",
    "input_type": {}
  },
  {
    "title": "Annotation background",
    "command": "-undercolor color",
    "description": "Sets the background color of the rectangle behind annotated text.",
    "example": "convert input -undercolor yellow -annotate +10+10 'Texte' output",
    "intent": "I want to add or set a background color behind annotated text to make it more readable (e.g., a yellow background).",
    "input_type": {}
  },
  {
    "title": "Unique colors",
    "command": "-unique-colors",
    "description": "Removes duplicates and keeps a single occurrence of each color.",
    "example": "convert input -unique-colors output",
    "intent": "I want to keep a single occurrence of each color in the image and remove duplicate colors (reduce the palette).",
    "input_type": {}
  },
  {
    "title": "resolution units",
    "command": "-units type",
    "description": "Sets the resolution units (PixelsPerInch or PixelsPerCentimeter).",
    "example": "convert input -units PixelsPerInch output",
    "input_type": {},
    "intent": "I want to set the image resolution units (pixels per inch / pixels per centimeter)."
  },
  {
    "title": "sharpening (unsharp)",
    "command": "-unsharp geometry",
    "description": "Enhances fine detail using an unsharp mask.",
    "example": "convert input -unsharp 0x2 output",
    "input_type": {},
    "intent": "I want to sharpen fine details in the image."
  },
  {
    "title": "verbose mode",
    "command": "-verbose",
    "description": "Displays detailed information about the image and processing.",
    "example": "convert input -verbose output",
    "input_type": {},
    "intent": "I want to see detailed information about the image and the operations performed."
  },
  {
    "title": "program version",
    "command": "-version",
    "description": "Displays the currently installed ImageMagick version.",
    "example": "-version",
    "input_type": {},
    "intent": "I want to know the ImageMagick version installed on my system."
  },
  {
    "title": "FlashPix view",
    "command": "-view",
    "description": "Applies a FlashPix view transform (rarely used).",
    "example": "convert input -view output",
    "input_type": {},
    "intent": "I want to apply a FlashPix view transform to the image."
  },
  {
    "title": "vignetting",
    "command": "-vignette geometry",
    "description": "Softens the image edges by creating a vignette effect.",
    "example": "convert input -vignette 0x10 output",
    "input_type": {},
    "intent": "I want to create a vignette effect by darkening and softening the image edges."
  },
  {
    "title": "virtual pixels",
    "command": "-virtual-pixel method",
    "description": "Defines how pixels outside the image boundaries are handled (tile, mirror, black...).",
    "example": "convert input -virtual-pixel tile -blur 0x5 output",
    "input_type": {},
    "intent": "I want to define how out-of-image pixels are handled (e.g., tile/mirror/black) during operations that touch the edges."
  },
  {
    "title": "sine wave",
    "command": "-wave geometry",
    "description": "Distorts the image using a sinusoidal wave.",
    "example": "convert input -wave 25x150 output",
    "input_type": {},
    "intent": "I want to create a ripple/wave distortion to give the image a wavy appearance."
  },
  {
    "title": "wavelet denoise",
    "command": "-wavelet-denoise threshold",
    "description": "Removes image noise using a wavelet transform.",
    "example": "convert input -wavelet-denoise 0.5 output",
    "input_type": {},
    "intent": "I want to remove or reduce image noise using wavelet denoising."
  },
  {
    "title": "font weight (weight)",
    "command": "-weight type",
    "description": "Sets the text weight (Normal, Bold, Light...).",
    "example": "convert input -weight Bold -annotate +10+10 'Texte' output",
    "input_type": {},
    "intent": "I want to set the text weight (e.g., Normal/Bold/Light) before adding an annotation."
  },
  {
    "title": "primary white point",
    "command": "-white-point point",
    "description": "Defines the chromaticity of white in the color space.",
    "example": "convert input -white-point 0.3127,0.3290 output",
    "input_type": {},
    "intent": "I want to set/choose the white point (the chromaticity of white) used for the image."
  },
  {
    "title": "white threshold",
    "command": "-white-threshold value",
    "description": "Forces all pixels above the threshold to become white.",
    "example": "convert input -white-threshold 80% output",
    "input_type": {},
    "intent": "I want to turn into white all pixels whose value/brightness exceeds a certain threshold."
  },
  {
    "title": "word break",
    "command": "-word-break type",
    "description": "Defines how line breaks occur (normal or break-word).",
    "example": "convert input -word-break break-word -annotate +10+10 'Texte long' output",
    "input_type": {},
    "intent": "I want to choose how text is split at line breaks (normal hyphenation / break-word) when adding text to an image."
  },
  {
    "title": "file writing",
    "command": "-write filename",
    "description": "Saves the image to a specific location, useful in command chains.",
    "example": "convert input -resize 50% -write output_half.png output_full.png",
    "input_type": {},
    "intent": "I want to write/save the image to a file at a specific location during the processing chain."
  },
  {
    "title": "image format conversion",
    "command": "convert input.format -background white -flatten output.format ",
    "description": "Converts an image from one format to another (for example PNG to JPEG, TIFF to WEBP, etc.).",
    "example": "convert input.png output.jpg",
    "input_type": {
      "pdf": "convert -density 150 input.pdf -background white -flatten output.xxx",
      "svg": "convert -background none input.svg output.xxx",
      "gif": "convert input.gif -coalesce output.xxx",
      "tiff": "convert input.tiff -depth 8 output.xxx",
      "heic": "convert input.heic output.xxx",
      "avif": "convert input.avif output.xxx"
    },
    "intent": "I want to convert my image from one format to another, for example from a PNG file to a JPEG file."
  },
  {
    "title": "Auto color and contrast correction",
    "command": "input -auto-level -contrast output",
    "description": "Automatically balances brightness and contrast to improve the image’s visual quality. Useful for dull or underexposed photos.",
    "example": "magick input.jpg -auto-level -contrast output.jpg",
    "intent": "I want to automatically enhance my image’s brightness and contrast to make it look clearer and more vivid.",
    "input_type": {
      "gif": "input.gif -coalesce -auto-level -contrast -layers optimize output.gif",
      "pdf": "-density 150 input.pdf -auto-level -contrast output.pdf",
      "svg": "-background none input.svg -auto-level -contrast output.svg"
    }
  }
]